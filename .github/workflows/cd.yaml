# # .github/workflows/cd.yaml

# name: CD Pipeline

# on:
#   push:
#     branches: [main]
#   workflow_dispatch:  # Manual trigger

# env:
#   AWS_REGION: us-east-1
#   ECR_REPOSITORY_TRAINING: fraud-detection-dev-training
#   ECR_REPOSITORY_SERVING: fraud-detection-dev-serving
#   EKS_CLUSTER_NAME: fraud-detection-dev

# jobs:
#   # ============================================
#   # Push to ECR
#   # ============================================
#   push:
#     name: Push to ECR
#     runs-on: ubuntu-latest
#     outputs:
#       image_tag: ${{ steps.meta.outputs.sha_short }}
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2

#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v3

#       - name: Generate image metadata
#         id: meta
#         run: |
#           SHA_SHORT=$(git rev-parse --short HEAD)
#           echo "sha_short=$SHA_SHORT" >> $GITHUB_OUTPUT

#       - name: Build and push training image
#         uses: docker/build-push-action@v5
#         with:
#           context: .
#           file: docker/Dockerfile.training
#           push: true
#           platforms: linux/amd64,linux/arm64
#           tags: |
#             ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_TRAINING }}:${{ steps.meta.outputs.sha_short }}
#             ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_TRAINING }}:latest
#           cache-from: type=gha
#           cache-to: type=gha,mode=max

#       - name: Build and push serving image
#         uses: docker/build-push-action@v5
#         with:
#           context: .
#           file: docker/Dockerfile.serving
#           push: true
#           platforms: linux/amd64,linux/arm64
#           tags: |
#             ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_SERVING }}:${{ steps.meta.outputs.sha_short }}
#             ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_SERVING }}:latest
#           cache-from: type=gha
#           cache-to: type=gha,mode=max

#   # ============================================
#   # Deploy to Staging
#   # ============================================
#   deploy-staging:
#     name: Deploy to Staging
#     runs-on: ubuntu-latest
#     needs: push
#     environment: staging
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2

#       - name: Update kubeconfig
#         run: |
#           aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

#       - name: Deploy to staging namespace
#         run: |
#           # Update image tag in manifests
#           export IMAGE_TAG=${{ needs.push.outputs.image_tag }}
#           export ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}

#           # Apply Kubernetes manifests (we'll create these later)
#           envsubst < k8s/staging/deployment.yaml | kubectl apply -f -

#           # Wait for rollout
#           kubectl rollout status deployment/fraud-detection-serving -n staging --timeout=300s

#       - name: Run smoke tests
#         run: |
#           # Get service URL
#           SERVICE_URL=$(kubectl get svc fraud-detection-serving -n staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

#           # Health check
#           curl -f http://$SERVICE_URL:8000/health || exit 1

#           echo "Staging deployment successful!"

#   # ============================================
#   # Deploy to Production
#   # ============================================
#   deploy-prod:
#     name: Deploy to Production
#     runs-on: ubuntu-latest
#     needs: [push, deploy-staging]
#     environment: production  # Requires manual approval
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2

#       - name: Update kubeconfig
#         run: |
#           aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

#       - name: Deploy to production namespace
#         run: |
#           # Update image tag in manifests
#           export IMAGE_TAG=${{ needs.push.outputs.image_tag }}
#           export ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}

#           # Apply Kubernetes manifests
#           envsubst < k8s/prod/deployment.yaml | kubectl apply -f -

#           # Wait for rollout
#           kubectl rollout status deployment/fraud-detection-serving -n prod --timeout=300s

#       - name: Verify deployment
#         run: |
#           # Get service URL
#           SERVICE_URL=$(kubectl get svc fraud-detection-serving -n prod -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

#           # Health check
#           curl -f http://$SERVICE_URL:8000/health || exit 1

#           echo "Production deployment successful!"
